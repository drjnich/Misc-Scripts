import sys, json, re, time, MySQLdb, ast
from tweepy.streaming import StreamListener
from tweepy import OAuthHandler
from tweepy import Stream

tw_consumer_key="XXXXXXXXXXXXX"
tw_consumer_secret="XXXXXXXXXXXXX"
tw_access_token="XXXXXXXXXXXXX"
tw_access_token_secret="XXXXXXXXXXXXX"

db_server="XXXXXXXXXXXXX"
db_user="XXXXXXXXXXXXX"
db_passwd="XXXXXXXXXXXXX"
db_name="XXXXXXXXXXXXX"

_DEBUG = False

def dbconnect(server, user, passwd, db):
        global dbconn
        global dbcur

        dbconn = MySQLdb.connect(server, user, passwd, db)
        dbcur = dbconn.cursor()
        return dbcur

def dbdisconnect():
        global dbconn
        global dbcur

        dbcur.close()
        dbconn.close()

def insert_user(userid, username, fullname):
        global dbconn
        global dbcur
        global _DEBUG

        if(_DEBUG):
                print "inserting user ["+username+"]"+'\n'
        else:
                try:
                        dbcur.execute("INSERT INTO twitter_users (u_id, username, fullname) VALUES (%s, %s, %s)", (userid, username, fullname))
                        dbconn.commit()
                except MySQLdb.Error, e:
                        print e

def get_useridlist():
        global dbconn
        global dbcur

        result = []

        try:
                dbcur.execute("SELECT u_id FROM twitter_users")
                data = dbcur.fetchall()
                for datum in data:
                        result.append(datum)
        except MySQLdb.Error, e:
                print e

        return result

def get_userlist():
        global dbconn
        global dbcur

        result = []

        try:
                dbcur.execute("SELECT username FROM twitter_users")
                data = dbcur.fetchall()
                for datum in data:
                        result.append(datum)
        except MySQLdb.Error, e:
                print e

        return result

def insert_message_text(m_id, u_id, date, message):
        global dbconn
        global dbcur
        global _DEBUG

        if(_DEBUG):
                print "inserting message ["+message+"]"+'\n'
        else:
                try:
                        dbcur.execute("INSERT INTO twitter_messages (m_id, u_id, date, message) VALUES (%s, %s, %s, %s)", (m_id, u_id, date, message))
                        dbconn.commit()
                except MySQLdb.Error, e:
                        print e

def insert_message_url(m_id, url1, url2):
        global dbconn
        global dbcur
        global _DEBUG

        if(_DEBUG):
                print "inserting url ["+url1+"] ["+url2+"]"+'\n'
        else:
                try:
                        dbcur.execute("INSERT INTO twitter_urls (m_id, url, url2) VALUES (%s, %s, %s)", (m_id, url1, url2))
                        dbconn.commit()
                except MySQLdb.Error, e:
                        print e

def insert_message_ref(m_id, key, value):
        global dbconn
        global dbcur
        global _DEBUG

        if(_DEBUG):
                print "inserting ref ["+key+"] ["+value+"]"+'\n'
        else:
                try:
                        dbcur.execute("INSERT INTO twitter_refs (m_id, ref, value) VALUES (%s, %s, %s)", (m_id, key, value))
                        dbconn.commit()
                except MySQLdb.Error, e:
                        print e

def find_vuln_reference(text):
        vids = re.findall("[cC][vV][eE][\-| |]?\d\d\d\d[\-| |]?\d\d\d\d", text)
        for vid in vids:
                insert_message_ref(m_id, "CVE", vid)

        vids = re.findall("[cC][aN][nN][\-| |]?\d\d\d\d[\-| |]?\d\d\d\d", text)
        for vid in vids:
                insert_message_ref(m_id, "CVE", vid)

        vids = re.findall("[mM][sS]\d\d\-\d\d\d", text)
        for vid in vids:
                insert_message_ref(m_id, "MSPATCH", vid)

def get_tags(text):
        tags = []

        if (re.search( r'exploit', text, re.I|re.M)):
                tags.append("exploit")
        if (re.search( r'vulnerabilit', text, re.I|re.M)):
                tags.append("vulnerability")
        if (re.search( r'0day', text, re.I|re.M)):
                tags.append("0day")
        if (re.search( r'zeroday', text, re.I|re.M)):
                tags.append("0day")
        if (re.search( r'zero day', text, re.I|re.M)):
                tags.append("0day")
        if (re.search( r'0 day', text, re.I|re.M)):
                tags.append("0day")
        if (re.search( r'0-day', text, re.I|re.M)):
                tags.append("0day")
        if (re.search( r'hacked', text, re.I|re.M)):
                tags.append("hacked")
        if (re.search( r'rootkit', text, re.I|re.M)):
                tags.append("rootkit")
        if (re.search( r'advisory', text, re.I|re.M)):
                tags.append("advisory")

        return sorted(set(tags))

def valid_tweet(text):
        tags = get_tags(text)

        if (len(tags) > 1):
                return True
        else:
                return False

def process_status_debug(status):
        print status['user']['screen_name']+" : "+status['text']+'\n'

def process_status(status):
        global seen_ids

        if (not 'id' in status):
                return

        # Get the message id
        m_id = status['id']

        # check to see if we have seen a particular message before
        if (m_id in seen_ids):
                # if by chance we have seen this tweet message id before, goto the next result
                return
        else:
                # it has not been seen before, therefore add it to the list
                seen_ids.append(m_id)

        # the text of the message
        message = status['text'].encode('ascii', 'ignore')

        if (valid_tweet(message)):
                # Get message date/time
                epoch = int(time.mktime(time.strptime(status['created_at'], '%a %b %d %H:%M:%S +0000 %Y')))
                date_time = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(epoch))

                # get the geo coordinates of the tweet if possible
                coordinates = status['coordinates']

                # Get user information
                u_id = status['user']['id_str']
                username = status['user']['screen_name']
                fullname = status['user']['name']

                # insert the usr info into the database
                insert_user(u_id, username, fullname)

                # insert the twitter message into the database
                insert_message_text(m_id, u_id, date_time, message)

                # extract urls
                for u in status['entities']['urls']:
                        url1 = u['url']
                        url2 = u['expanded_url']

                        # insert the url information into the database
                        insert_message_url(m_id, url1, url2)

                # attempt to extract vulnerability references
                find_vuln_reference(message)

#       else:
#               print "NOT VALID: "+message

class StdOutListener(StreamListener):
        def on_data(self, data):
                process_status(json.loads(data))

        def on_error(self, status):
                print status

# #################################################################
#
# MAIN
#
# #################################################################

if __name__ == '__main__':
        # setup global variables
        dbconn = MySQLdb.connect(db_server, db_user, db_passwd, db_name)
        dbcur = dbconn.cursor()

        seen_ids = []

        l = StdOutListener()
        auth = OAuthHandler(tw_consumer_key, tw_consumer_secret)
        auth.set_access_token(tw_access_token, tw_access_token_secret)

        stream = Stream(auth, l)
        stream.filter(track=['exploit,exploits,vulnerability,vulnerabilties,0day,zeroday,zero day,0 day,0-day,hacked,rootkit,advisory'])

        dbdisconnect()
